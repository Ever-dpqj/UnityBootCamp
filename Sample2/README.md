# 유니티 생명주기 함수 (Life Cycle)
Unity BootCamp 14th projects
###### 유니티에서는 프로그램의 실행부터 종료까지의 작업 영역을 함수로 제공합니다.
***



## 어휘


**코루틴** : 코드를 일시중지하고 특정 조건이 충족될 때 까지 실행을 delay 시킬수 있는 기능. (ex. 3초 뒤에 오브젝트를 파괴.)

**캐시** : 자주 사용되는 데이터를 미리 복사해두는 임시 장소.

**시간 지역성** : 가장 최근 값이 다시 사용될 가능성이 높다.

**공간 지역성** : 최근에 접근한 주소와 인접한 주소가 다시 사용될 가능성이 높다.




## 초기화 함수
> |이벤트|특징|사용|
> |--|-|-|
> |Awake()|가장 먼저 실행, 한번만 호출, 코루틴 실행 불가|참조를 만들어야하는 경우|
> |OnEnable()|오브젝트나 스크립트가 활성화될때 호출|온오프시 수행해야하는 작업|
> |Start()|Awake() 이후에 실행, 한번만 호출, 코루틴 실행 가능|게임로직, 초기화된 데이터를 기반으로 작업 수행, 코루틴 작업|

## 업데이트 함수
> |이벤트|특징|사용|
> |--|-|-|
> |Update()|1초에 60프레임정도 실행|이동, 클릭, 메인로직을 실행하는경우|
> |FixedUpdate()|설정된 주기마다 실행(Fixed Timestep)|물리 계산(Rigidbody)|
> |LateUpdate()|모든 업데이트 이후에 실행|카메라 추적|

## 함수 사용시 주의사항

> 실행순서가 같은 함수끼리는 스크립트를 적용한 순서대로 실행되기 때문에 Null 레퍼런스 오류가 발생할 수 있다.

***
***
***

# 유니티 벡터와 메모리

값 : 변수에 데이터가 직접 저장

참조 : 변수에 데이터가 저장된 메모리 주소값이 저장



## 대표적인 메모리

**1. 코드**
> 텍스트 영역, 프로그램 종료까지 남아있는 값

**2. 데이터**
> 전역변수, 정적변수가 저장되는 영역

###### ※  C#에서는 전역변수 대신 클래스 수준의 정적변수를 사용.

###### ※  static이 붙은 변수는 별도의 객체 생성없이 접근하는것이 가능


**3. 힙**
> 프로그래머가 직접 할당&해제를 진행하는 영역

###### ※  힙 -> 참조타입

###### ※  자동관리지만 메모리를 많이 사용 -> 성능 저하 가능성


**4. 스택**
> 자동으로 사용하는 임시 메모리 영역

###### ※  함수의 호출이 완료되면 사라지는 데이터

###### ※  매우 빠른 속도로 접근 가능

###### ※  너무 많은 호출은 과부하를 일으킬수있음(오버플로우)

###### ※  Last In First Out(마지막에 들어온 데이터가 먼저 나감)

## 벡터의 특징
1. 값 타입(구조체 struct)
-> 참조가 아니기 때문에 계산이 빠름
2. 벡터의 계산 보조 기능 많이 제공 (magnitude, normalized, Dot, Cross...)
3. 벡터는 스택영역의 메모리에서 저장


## 벡터의 거리
```cs
        Vector3 posA = A_Cube.position;
        Vector3 posB = B_Cube.position;

        Vector3 BtoA = posB - posA;
        Vector3 AtoB = posA - posB;
        
        float distance = Vector3.Distance(posA, posB);
        //Distance() -> 3차원에서의 점과 점 거리공식
```

## Vector3에서의 Lerp, Slerp

|종류|함수|특징|
|--|--|--|
|선형 보간(LinearInter)|Vector3.Lerp()|직선 이동|
|구형 선형 보간(SphericaInter)|Vector3.Slerp()|곡선 운동, 회전 및 방향 전환|



